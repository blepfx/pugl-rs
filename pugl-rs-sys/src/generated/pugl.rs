/* automatically generated by rust-bindgen 0.71.1 */

#[doc = "A pixel coordinate within/of a view.\n\nThis is relative to the top left corner of the view's parent, or to the top\nleft corner of the view itself, depending on the context.\n\nThere are platform-imposed limits on window positions.  For portability,\napplications should keep coordinates between -16000 and 16000.  Note that\nnegative frame coordinates are possible, for example with multiple screens."]
pub type PuglCoord = i16;
#[doc = "A pixel span (width or height) within/of a view.\n\nDue to platform limits, the span of a view in either dimension should be\nbetween 1 and 10000."]
pub type PuglSpan = u16;
#[doc = " A 2-dimensional position within/of a view"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglPoint {
    pub x: PuglCoord,
    pub y: PuglCoord,
}
#[doc = " A 2-dimensional size within/of a view"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglArea {
    pub width: PuglSpan,
    pub height: PuglSpan,
}
#[doc = "The application class name.\n\nThis is a stable identifier for the application, which should be a short\ncamel-case name like \"MyApp\".  This should be the same for every instance\nof the application, but different from any other application.  On X11 and\nWindows, it is used to set the class name of windows (that underlie\nrealized views), which is used for things like loading configuration, or\ncustom window management rules."]
pub const PUGL_CLASS_NAME: PuglStringHint = 1;
#[doc = "The title of the window or application.\n\nThis is used by the system to display a title for the application or\nwindow, for example in title bars or window/application switchers.  It is\nonly used to display a label to the user, not as an identifier, and can\nchange over time to reflect the current state of the application.  For\nexample, it is common for programs to add the name of the current\ndocument, like \"myfile.txt - Fancy Editor\"."]
pub const PUGL_WINDOW_TITLE: PuglStringHint = 2;
#[doc = " A string property for configuration"]
pub type PuglStringHint = ::std::os::raw::c_uint;
#[doc = "< No event"]
pub const PUGL_NOTHING: PuglEventType = 0;
#[doc = "< View realized, a #PuglRealizeEvent"]
pub const PUGL_REALIZE: PuglEventType = 1;
#[doc = "< View unrealizeed, a #PuglUnrealizeEvent"]
pub const PUGL_UNREALIZE: PuglEventType = 2;
#[doc = "< View configured, a #PuglConfigureEvent"]
pub const PUGL_CONFIGURE: PuglEventType = 3;
#[doc = "< View ready to draw, a #PuglUpdateEvent"]
pub const PUGL_UPDATE: PuglEventType = 4;
#[doc = "< View must be drawn, a #PuglExposeEvent"]
pub const PUGL_EXPOSE: PuglEventType = 5;
#[doc = "< View will be closed, a #PuglCloseEvent"]
pub const PUGL_CLOSE: PuglEventType = 6;
#[doc = "< Keyboard focus entered view, a #PuglFocusEvent"]
pub const PUGL_FOCUS_IN: PuglEventType = 7;
#[doc = "< Keyboard focus left view, a #PuglFocusEvent"]
pub const PUGL_FOCUS_OUT: PuglEventType = 8;
#[doc = "< Key pressed, a #PuglKeyEvent"]
pub const PUGL_KEY_PRESS: PuglEventType = 9;
#[doc = "< Key released, a #PuglKeyEvent"]
pub const PUGL_KEY_RELEASE: PuglEventType = 10;
#[doc = "< Character entered, a #PuglTextEvent"]
pub const PUGL_TEXT: PuglEventType = 11;
#[doc = "< Pointer entered view, a #PuglCrossingEvent"]
pub const PUGL_POINTER_IN: PuglEventType = 12;
#[doc = "< Pointer left view, a #PuglCrossingEvent"]
pub const PUGL_POINTER_OUT: PuglEventType = 13;
#[doc = "< Mouse button pressed, a #PuglButtonEvent"]
pub const PUGL_BUTTON_PRESS: PuglEventType = 14;
#[doc = "< Mouse button released, a #PuglButtonEvent"]
pub const PUGL_BUTTON_RELEASE: PuglEventType = 15;
#[doc = "< Pointer moved, a #PuglMotionEvent"]
pub const PUGL_MOTION: PuglEventType = 16;
#[doc = "< Scrolled, a #PuglScrollEvent"]
pub const PUGL_SCROLL: PuglEventType = 17;
#[doc = "< Custom client message, a #PuglClientEvent"]
pub const PUGL_CLIENT: PuglEventType = 18;
#[doc = "< Timer triggered, a #PuglTimerEvent"]
pub const PUGL_TIMER: PuglEventType = 19;
#[doc = "< Recursive loop entered, a #PuglLoopEnterEvent"]
pub const PUGL_LOOP_ENTER: PuglEventType = 20;
#[doc = "< Recursive loop left, a #PuglLoopLeaveEvent"]
pub const PUGL_LOOP_LEAVE: PuglEventType = 21;
#[doc = "< Data offered from clipboard, a #PuglDataOfferEvent"]
pub const PUGL_DATA_OFFER: PuglEventType = 22;
#[doc = "< Data available from clipboard, a #PuglDataEvent"]
pub const PUGL_DATA: PuglEventType = 23;
#[doc = " The type of a PuglEvent"]
pub type PuglEventType = ::std::os::raw::c_uint;
#[doc = "< Event is synthetic"]
pub const PUGL_IS_SEND_EVENT: PuglEventFlag = 1;
#[doc = "< Event is a hint (not direct user input)"]
pub const PUGL_IS_HINT: PuglEventFlag = 2;
#[doc = " Common flags for all event types"]
pub type PuglEventFlag = ::std::os::raw::c_uint;
#[doc = " Bitwise OR of #PuglEventFlag values"]
pub type PuglEventFlags = u32;
#[doc = "< Crossing due to pointer motion"]
pub const PUGL_CROSSING_NORMAL: PuglCrossingMode = 0;
#[doc = "< Crossing due to a grab"]
pub const PUGL_CROSSING_GRAB: PuglCrossingMode = 1;
#[doc = "< Crossing due to a grab release"]
pub const PUGL_CROSSING_UNGRAB: PuglCrossingMode = 2;
#[doc = " Reason for a PuglCrossingEvent"]
pub type PuglCrossingMode = ::std::os::raw::c_uint;
#[doc = " Common header for all event structs"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglAnyEvent {
    #[doc = "< Event type"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
}
#[doc = " View is mapped to a real window and potentially visible"]
pub const PUGL_VIEW_STYLE_MAPPED: PuglViewStyleFlag = 1;
#[doc = " View is modal, typically a dialog box of its transient parent"]
pub const PUGL_VIEW_STYLE_MODAL: PuglViewStyleFlag = 2;
#[doc = " View should be above most others"]
pub const PUGL_VIEW_STYLE_ABOVE: PuglViewStyleFlag = 4;
#[doc = " View should be below most others"]
pub const PUGL_VIEW_STYLE_BELOW: PuglViewStyleFlag = 8;
#[doc = " View is minimized, shaded, or otherwise invisible"]
pub const PUGL_VIEW_STYLE_HIDDEN: PuglViewStyleFlag = 16;
#[doc = " View is maximized to fill the screen vertically"]
pub const PUGL_VIEW_STYLE_TALL: PuglViewStyleFlag = 32;
#[doc = " View is maximized to fill the screen horizontally"]
pub const PUGL_VIEW_STYLE_WIDE: PuglViewStyleFlag = 64;
#[doc = " View is enlarged to fill the entire screen with no decorations"]
pub const PUGL_VIEW_STYLE_FULLSCREEN: PuglViewStyleFlag = 128;
#[doc = " View is being resized"]
pub const PUGL_VIEW_STYLE_RESIZING: PuglViewStyleFlag = 256;
#[doc = " View is ready for input or otherwise demanding attention"]
pub const PUGL_VIEW_STYLE_DEMANDING: PuglViewStyleFlag = 512;
#[doc = "View style flags.\n\nStyle flags reflect special modes and states supported by the window system.\nApplications should ideally use a single main view, but can monitor or\nmanipulate style flags to better integrate with the window system."]
pub type PuglViewStyleFlag = ::std::os::raw::c_uint;
#[doc = " Bitwise OR of #PuglViewStyleFlag values"]
pub type PuglViewStyleFlags = u32;
#[doc = "View realize event.\n\nThis event is sent when a view is realized before it is first displayed,\nwith the graphics context entered.  This is typically used for setting up\nthe graphics system, for example by loading OpenGL extensions.\n\nThis event type has no extra fields."]
pub type PuglRealizeEvent = PuglAnyEvent;
#[doc = "View unrealize event.\n\nThis event is the counterpart to #PuglRealizeEvent, and is sent when the\nview will no longer be displayed.  This is typically used for tearing down\nthe graphics system, or otherwise freeing any resources allocated when the\nrealize event was handled.\n\nThis event type has no extra fields."]
pub type PuglUnrealizeEvent = PuglAnyEvent;
#[doc = "View resize or move event.\n\nA configure event is sent whenever the view is resized or moved.  When a\nconfigure event is received, the graphics context is active but not set up\nfor drawing.  For example, it is valid to adjust the OpenGL viewport or\notherwise configure the context, but not to draw anything."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglConfigureEvent {
    #[doc = "< #PUGL_CONFIGURE"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Parent-relative X coordinate of view"]
    pub x: PuglCoord,
    #[doc = "< Parent-relative Y coordinate of view"]
    pub y: PuglCoord,
    #[doc = "< Width of view"]
    pub width: PuglSpan,
    #[doc = "< Height of view"]
    pub height: PuglSpan,
    #[doc = "< Bitwise OR of #PuglViewStyleFlag flags"]
    pub style: PuglViewStyleFlags,
}
#[doc = "Recursive loop enter event.\n\nThis event is sent when the window system enters a recursive loop.  The main\nloop will be stalled and no expose events will be received while in the\nrecursive loop.  To give the application full control, Pugl does not do any\nspecial handling of this situation, but this event can be used to install a\ntimer to perform continuous actions (such as drawing) on platforms that do\nthis.\n\n- MacOS: A recursive loop is entered while the window is being live resized.\n\n- Windows: A recursive loop is entered while the window is being live\nresized or the menu is shown.\n\n- X11: A recursive loop is never entered and the event loop runs as usual\nwhile the view is being resized.\n\nThis event type has no extra fields."]
pub type PuglLoopEnterEvent = PuglAnyEvent;
#[doc = "Recursive loop leave event.\n\nThis event is sent after a loop enter event when the recursive loop is\nfinished and normal iteration will continue.\n\nThis event type has no extra fields."]
pub type PuglLoopLeaveEvent = PuglAnyEvent;
#[doc = "View close event.\n\nThis event is sent when the view is to be closed, for example when the user\nclicks the close button.\n\nThis event type has no extra fields."]
pub type PuglCloseEvent = PuglAnyEvent;
#[doc = "View update event.\n\nThis event is sent to every view near the end of a main loop iteration when\nany pending exposures are about to be redrawn.  It is typically used to mark\nregions to expose with puglObscureView() or puglObscureRegion().  For\nexample, to continuously animate, obscure the view when an update event is\nreceived, and it will receive an expose event shortly afterwards."]
pub type PuglUpdateEvent = PuglAnyEvent;
#[doc = "Expose event for when a region must be redrawn.\n\nWhen an expose event is received, the graphics context is active, and the\nview must draw the entire specified region.  The contents of the region are\nundefined, there is no preservation of anything drawn previously."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglExposeEvent {
    #[doc = "< #PUGL_EXPOSE"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< View-relative top-left X coordinate of region"]
    pub x: PuglCoord,
    #[doc = "< View-relative top-left Y coordinate of region"]
    pub y: PuglCoord,
    #[doc = "< Width of exposed region"]
    pub width: PuglSpan,
    #[doc = "< Height of exposed region"]
    pub height: PuglSpan,
}
#[doc = "< Sentinel value for no key"]
pub const PUGL_KEY_NONE: PuglKey = 0;
#[doc = "< Backspace"]
pub const PUGL_KEY_BACKSPACE: PuglKey = 8;
#[doc = "< Tab"]
pub const PUGL_KEY_TAB: PuglKey = 9;
#[doc = "< Enter"]
pub const PUGL_KEY_ENTER: PuglKey = 13;
#[doc = "< Escape"]
pub const PUGL_KEY_ESCAPE: PuglKey = 27;
#[doc = "< Delete"]
pub const PUGL_KEY_DELETE: PuglKey = 127;
#[doc = "< Space"]
pub const PUGL_KEY_SPACE: PuglKey = 32;
#[doc = "< F1"]
pub const PUGL_KEY_F1: PuglKey = 57344;
#[doc = "< F2"]
pub const PUGL_KEY_F2: PuglKey = 57345;
#[doc = "< F3"]
pub const PUGL_KEY_F3: PuglKey = 57346;
#[doc = "< F4"]
pub const PUGL_KEY_F4: PuglKey = 57347;
#[doc = "< F5"]
pub const PUGL_KEY_F5: PuglKey = 57348;
#[doc = "< F6"]
pub const PUGL_KEY_F6: PuglKey = 57349;
#[doc = "< F7"]
pub const PUGL_KEY_F7: PuglKey = 57350;
#[doc = "< F8"]
pub const PUGL_KEY_F8: PuglKey = 57351;
#[doc = "< F9"]
pub const PUGL_KEY_F9: PuglKey = 57352;
#[doc = "< F10"]
pub const PUGL_KEY_F10: PuglKey = 57353;
#[doc = "< F11"]
pub const PUGL_KEY_F11: PuglKey = 57360;
#[doc = "< F12"]
pub const PUGL_KEY_F12: PuglKey = 57361;
#[doc = "< Page Up"]
pub const PUGL_KEY_PAGE_UP: PuglKey = 57393;
#[doc = "< Page Down"]
pub const PUGL_KEY_PAGE_DOWN: PuglKey = 57394;
#[doc = "< End"]
pub const PUGL_KEY_END: PuglKey = 57395;
#[doc = "< Home"]
pub const PUGL_KEY_HOME: PuglKey = 57396;
#[doc = "< Left"]
pub const PUGL_KEY_LEFT: PuglKey = 57397;
#[doc = "< Up"]
pub const PUGL_KEY_UP: PuglKey = 57398;
#[doc = "< Right"]
pub const PUGL_KEY_RIGHT: PuglKey = 57399;
#[doc = "< Down"]
pub const PUGL_KEY_DOWN: PuglKey = 57400;
#[doc = "< Print Screen"]
pub const PUGL_KEY_PRINT_SCREEN: PuglKey = 57409;
#[doc = "< Insert"]
pub const PUGL_KEY_INSERT: PuglKey = 57410;
#[doc = "< Pause/Break"]
pub const PUGL_KEY_PAUSE: PuglKey = 57411;
#[doc = "< Menu"]
pub const PUGL_KEY_MENU: PuglKey = 57412;
#[doc = "< Num Lock"]
pub const PUGL_KEY_NUM_LOCK: PuglKey = 57413;
#[doc = "< Scroll Lock"]
pub const PUGL_KEY_SCROLL_LOCK: PuglKey = 57414;
#[doc = "< Caps Lock"]
pub const PUGL_KEY_CAPS_LOCK: PuglKey = 57415;
#[doc = "< Left Shift"]
pub const PUGL_KEY_SHIFT_L: PuglKey = 57425;
#[doc = "< Right Shift"]
pub const PUGL_KEY_SHIFT_R: PuglKey = 57426;
#[doc = "< Left Control"]
pub const PUGL_KEY_CTRL_L: PuglKey = 57427;
#[doc = "< Right Control"]
pub const PUGL_KEY_CTRL_R: PuglKey = 57428;
#[doc = "< Left Alt"]
pub const PUGL_KEY_ALT_L: PuglKey = 57429;
#[doc = "< Right Alt / AltGr"]
pub const PUGL_KEY_ALT_R: PuglKey = 57430;
#[doc = "< Left Super"]
pub const PUGL_KEY_SUPER_L: PuglKey = 57431;
#[doc = "< Right Super"]
pub const PUGL_KEY_SUPER_R: PuglKey = 57432;
#[doc = "< Keypad 0"]
pub const PUGL_KEY_PAD_0: PuglKey = 57440;
#[doc = "< Keypad 1"]
pub const PUGL_KEY_PAD_1: PuglKey = 57441;
#[doc = "< Keypad 2"]
pub const PUGL_KEY_PAD_2: PuglKey = 57442;
#[doc = "< Keypad 3"]
pub const PUGL_KEY_PAD_3: PuglKey = 57443;
#[doc = "< Keypad 4"]
pub const PUGL_KEY_PAD_4: PuglKey = 57444;
#[doc = "< Keypad 5"]
pub const PUGL_KEY_PAD_5: PuglKey = 57445;
#[doc = "< Keypad 6"]
pub const PUGL_KEY_PAD_6: PuglKey = 57446;
#[doc = "< Keypad 7"]
pub const PUGL_KEY_PAD_7: PuglKey = 57447;
#[doc = "< Keypad 8"]
pub const PUGL_KEY_PAD_8: PuglKey = 57448;
#[doc = "< Keypad 9"]
pub const PUGL_KEY_PAD_9: PuglKey = 57449;
#[doc = "< Keypad Enter"]
pub const PUGL_KEY_PAD_ENTER: PuglKey = 57456;
#[doc = "< Keypad Page Up"]
pub const PUGL_KEY_PAD_PAGE_UP: PuglKey = 57457;
#[doc = "< Keypad Page Down"]
pub const PUGL_KEY_PAD_PAGE_DOWN: PuglKey = 57458;
#[doc = "< Keypad End"]
pub const PUGL_KEY_PAD_END: PuglKey = 57459;
#[doc = "< Keypad Home"]
pub const PUGL_KEY_PAD_HOME: PuglKey = 57460;
#[doc = "< Keypad Left"]
pub const PUGL_KEY_PAD_LEFT: PuglKey = 57461;
#[doc = "< Keypad Up"]
pub const PUGL_KEY_PAD_UP: PuglKey = 57462;
#[doc = "< Keypad Right"]
pub const PUGL_KEY_PAD_RIGHT: PuglKey = 57463;
#[doc = "< Keypad Down"]
pub const PUGL_KEY_PAD_DOWN: PuglKey = 57464;
#[doc = "< Keypad Clear/Begin"]
pub const PUGL_KEY_PAD_CLEAR: PuglKey = 57501;
#[doc = "< Keypad Insert"]
pub const PUGL_KEY_PAD_INSERT: PuglKey = 57502;
#[doc = "< Keypad Delete"]
pub const PUGL_KEY_PAD_DELETE: PuglKey = 57503;
#[doc = "< Keypad Equal"]
pub const PUGL_KEY_PAD_EQUAL: PuglKey = 57504;
#[doc = "< Keypad Multiply"]
pub const PUGL_KEY_PAD_MULTIPLY: PuglKey = 57514;
#[doc = "< Keypad Add"]
pub const PUGL_KEY_PAD_ADD: PuglKey = 57515;
#[doc = "< Keypad Separator"]
pub const PUGL_KEY_PAD_SEPARATOR: PuglKey = 57516;
#[doc = "< Keypad Subtract"]
pub const PUGL_KEY_PAD_SUBTRACT: PuglKey = 57517;
#[doc = "< Keypad Decimal"]
pub const PUGL_KEY_PAD_DECIMAL: PuglKey = 57518;
#[doc = "< Keypad Divide"]
pub const PUGL_KEY_PAD_DIVIDE: PuglKey = 57519;
#[doc = "Keyboard key codepoints.\n\nAll keys are identified by a Unicode code point in PuglKeyEvent::key.  This\nenumeration defines constants for special keys that do not have a standard\ncode point, and some convenience constants for control characters.  Note\nthat all keys are handled in the same way, this enumeration is just for\nconvenience when writing hard-coded key bindings.\n\nKeys that do not have a standard code point use values in the Private Use\nArea in the Basic Multilingual Plane (`U+E000` to `U+F8FF`).  Applications\nmust take care to not interpret these values beyond key detection, the\nmapping used here is arbitrary and specific to Pugl."]
pub type PuglKey = ::std::os::raw::c_uint;
#[doc = "< Shift pressed"]
pub const PUGL_MOD_SHIFT: PuglMod = 1;
#[doc = "< Control pressed"]
pub const PUGL_MOD_CTRL: PuglMod = 2;
#[doc = "< Alt/Option pressed"]
pub const PUGL_MOD_ALT: PuglMod = 4;
#[doc = "< Super/Command/Windows pressed"]
pub const PUGL_MOD_SUPER: PuglMod = 8;
#[doc = "< Num lock enabled"]
pub const PUGL_MOD_NUM_LOCK: PuglMod = 16;
#[doc = "< Scroll lock enabled"]
pub const PUGL_MOD_SCROLL_LOCK: PuglMod = 32;
#[doc = "< Caps lock enabled"]
pub const PUGL_MOD_CAPS_LOCK: PuglMod = 64;
#[doc = " Keyboard modifier flags"]
pub type PuglMod = ::std::os::raw::c_uint;
#[doc = " Bitwise OR of #PuglMod values"]
pub type PuglMods = u32;
#[doc = "Keyboard focus event.\n\nThis event is sent whenever the view gains or loses the keyboard focus.  The\nview with the keyboard focus will receive any key press or release events."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglFocusEvent {
    #[doc = "< #PUGL_FOCUS_IN or #PUGL_FOCUS_OUT"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Reason for focus change"]
    pub mode: PuglCrossingMode,
}
#[doc = "Key press or release event.\n\nThis event represents low-level key presses and releases.  This can be used\nfor \"direct\" keyboard handling like key bindings, but must not be\ninterpreted as text input.\n\nKeys are represented portably as Unicode code points, using the \"natural\"\ncode point for the key where possible (see #PuglKey for details).  The `key`\nfield is the code for the pressed key, without any modifiers applied.  For\nexample, a press or release of the 'A' key will have `key` 97 ('a')\nregardless of whether shift or control are being held.\n\nAlternatively, the raw `keycode` can be used to work directly with physical\nkeys, but note that this value is not portable and differs between platforms\nand hardware."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglKeyEvent {
    #[doc = "< #PUGL_KEY_PRESS or #PUGL_KEY_RELEASE"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Time in seconds"]
    pub time: f64,
    #[doc = "< View-relative X coordinate"]
    pub x: f64,
    #[doc = "< View-relative Y coordinate"]
    pub y: f64,
    #[doc = "< Root-relative X coordinate"]
    pub xRoot: f64,
    #[doc = "< Root-relative Y coordinate"]
    pub yRoot: f64,
    #[doc = "< Bitwise OR of #PuglMod flags"]
    pub state: PuglMods,
    #[doc = "< Raw key code"]
    pub keycode: u32,
    #[doc = "< Unshifted Unicode character code, or 0"]
    pub key: u32,
}
#[doc = "Character input event.\n\nThis event represents text input, usually as the result of a key press.  The\ntext is given both as a Unicode character code and a UTF-8 string.\n\nNote that this event is generated by the platform's input system, so there\nis not necessarily a direct correspondence between text events and physical\nkey presses.  For example, with some input methods a sequence of several key\npresses will generate a single character."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglTextEvent {
    #[doc = "< #PUGL_TEXT"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Time in seconds"]
    pub time: f64,
    #[doc = "< View-relative X coordinate"]
    pub x: f64,
    #[doc = "< View-relative Y coordinate"]
    pub y: f64,
    #[doc = "< Root-relative X coordinate"]
    pub xRoot: f64,
    #[doc = "< Root-relative Y coordinate"]
    pub yRoot: f64,
    #[doc = "< Bitwise OR of #PuglMod flags"]
    pub state: PuglMods,
    #[doc = "< Raw key code"]
    pub keycode: u32,
    #[doc = "< Unicode character code"]
    pub character: u32,
    #[doc = "< UTF-8 string"]
    pub string: [::std::os::raw::c_char; 8usize],
}
#[doc = "< Scroll up"]
pub const PUGL_SCROLL_UP: PuglScrollDirection = 0;
#[doc = "< Scroll down"]
pub const PUGL_SCROLL_DOWN: PuglScrollDirection = 1;
#[doc = "< Scroll left"]
pub const PUGL_SCROLL_LEFT: PuglScrollDirection = 2;
#[doc = "< Scroll right"]
pub const PUGL_SCROLL_RIGHT: PuglScrollDirection = 3;
#[doc = "< Smooth scroll in any direction"]
pub const PUGL_SCROLL_SMOOTH: PuglScrollDirection = 4;
#[doc = "Scroll direction.\n\nDescribes the direction of a #PuglScrollEvent along with whether the scroll\nis a \"smooth\" scroll.  The discrete directions are for devices like mouse\nwheels with constrained axes, while a smooth scroll is for those with\narbitrary scroll direction freedom, like some touchpads."]
pub type PuglScrollDirection = ::std::os::raw::c_uint;
#[doc = "Pointer enter or leave event.\n\nThis event is sent when the pointer enters or leaves the view.  This can\nhappen for several reasons (not just the user dragging the pointer over the\nwindow edge), as described by the `mode` field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglCrossingEvent {
    #[doc = "< #PUGL_POINTER_IN or #PUGL_POINTER_OUT"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Time in seconds"]
    pub time: f64,
    #[doc = "< View-relative X coordinate"]
    pub x: f64,
    #[doc = "< View-relative Y coordinate"]
    pub y: f64,
    #[doc = "< Root-relative X coordinate"]
    pub xRoot: f64,
    #[doc = "< Root-relative Y coordinate"]
    pub yRoot: f64,
    #[doc = "< Bitwise OR of #PuglMod flags"]
    pub state: PuglMods,
    #[doc = "< Reason for crossing"]
    pub mode: PuglCrossingMode,
}
#[doc = "Button press or release event.\n\nButton numbers start from 0, and are ordered: primary, secondary, middle.\nSo, on a typical right-handed mouse, the button numbers are:\n\nLeft: 0\nRight: 1\nMiddle (often a wheel): 2\n\nHigher button numbers are reported in the same order they are represented on\nthe system.  There is no universal standard here, but buttons 3 and 4 are\ntypically a pair of buttons or a rocker, which are usually bound to \"back\"\nand \"forward\" operations.\n\nNote that these numbers may differ from those used on the underlying\nplatform, since they are manipulated to provide a consistent portable API."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglButtonEvent {
    #[doc = "< #PUGL_BUTTON_PRESS or #PUGL_BUTTON_RELEASE"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Time in seconds"]
    pub time: f64,
    #[doc = "< View-relative X coordinate"]
    pub x: f64,
    #[doc = "< View-relative Y coordinate"]
    pub y: f64,
    #[doc = "< Root-relative X coordinate"]
    pub xRoot: f64,
    #[doc = "< Root-relative Y coordinate"]
    pub yRoot: f64,
    #[doc = "< Bitwise OR of #PuglMod flags"]
    pub state: PuglMods,
    #[doc = "< Button number starting from 0"]
    pub button: u32,
}
#[doc = "Pointer motion event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglMotionEvent {
    #[doc = "< #PUGL_MOTION"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Time in seconds"]
    pub time: f64,
    #[doc = "< View-relative X coordinate"]
    pub x: f64,
    #[doc = "< View-relative Y coordinate"]
    pub y: f64,
    #[doc = "< Root-relative X coordinate"]
    pub xRoot: f64,
    #[doc = "< Root-relative Y coordinate"]
    pub yRoot: f64,
    #[doc = "< Bitwise OR of #PuglMod flags"]
    pub state: PuglMods,
}
#[doc = "Scroll event.\n\nThe scroll distance is expressed in \"lines\", an arbitrary unit that\ncorresponds to a single tick of a detented mouse wheel.  For example, `dy` =\n1.0 scrolls 1 line up.  Some systems and devices support finer resolution\nand/or higher values for fast scrolls, so programs should handle any value\ngracefully."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglScrollEvent {
    #[doc = "< #PUGL_SCROLL"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Time in seconds"]
    pub time: f64,
    #[doc = "< View-relative X coordinate"]
    pub x: f64,
    #[doc = "< View-relative Y coordinate"]
    pub y: f64,
    #[doc = "< Root-relative X coordinate"]
    pub xRoot: f64,
    #[doc = "< Root-relative Y coordinate"]
    pub yRoot: f64,
    #[doc = "< Bitwise OR of #PuglMod flags"]
    pub state: PuglMods,
    #[doc = "< Scroll direction"]
    pub direction: PuglScrollDirection,
    #[doc = "< Scroll X distance in lines"]
    pub dx: f64,
    #[doc = "< Scroll Y distance in lines"]
    pub dy: f64,
}
#[doc = "Custom client message event.\n\nThis can be used to send a custom message to a view, which is delivered via\nthe window system and processed in the event loop as usual.  Among other\nthings, this makes it possible to wake up the event loop for any reason."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglClientEvent {
    #[doc = "< #PUGL_CLIENT"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Client-specific data"]
    pub data1: usize,
    #[doc = "< Client-specific data"]
    pub data2: usize,
}
#[doc = "Timer event.\n\nThis event is sent at the regular interval specified in the call to\npuglStartTimer() that activated it.\n\nThe `id` is the application-specific ID given to puglStartTimer() which\ndistinguishes this timer from others.  It should always be checked in the\nevent handler, even in applications that register only one timer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglTimerEvent {
    #[doc = "< #PUGL_TIMER"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Timer ID"]
    pub id: usize,
}
#[doc = "Clipboard data offer event.\n\nThis event is sent when a clipboard has data present, possibly with several\ndatatypes.  While handling this event, the types can be investigated with\npuglGetClipboardType() to decide whether to accept the offer with\npuglAcceptOffer()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglDataOfferEvent {
    #[doc = "< #PUGL_DATA_OFFER"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Time in seconds"]
    pub time: f64,
}
#[doc = "Clipboard data event.\n\nThis event is sent after accepting a data offer when the data has been\nretrieved and converted.  While handling this event, the data can be\naccessed with puglGetClipboard()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglDataEvent {
    #[doc = "< #PUGL_DATA"]
    pub type_: PuglEventType,
    #[doc = "< Bitwise OR of #PuglEventFlag values"]
    pub flags: PuglEventFlags,
    #[doc = "< Time in seconds"]
    pub time: f64,
    #[doc = "< Index of datatype"]
    pub typeIndex: u32,
}
#[doc = "View event.\n\nThis is a union of all event types.  The type must be checked to determine\nwhich fields are safe to access.  A pointer to PuglEvent can either be cast\nto the appropriate type, or the union members used.\n\nThe graphics system may only be accessed when handling certain events.  The\ngraphics context is active for #PUGL_REALIZE, #PUGL_UNREALIZE,\n#PUGL_CONFIGURE, and #PUGL_EXPOSE, but only enabled for drawing for\n#PUGL_EXPOSE."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union PuglEvent {
    #[doc = "< Valid for all event types"]
    pub any: PuglAnyEvent,
    #[doc = "< Event type"]
    pub type_: PuglEventType,
    #[doc = "< #PUGL_BUTTON_PRESS, #PUGL_BUTTON_RELEASE"]
    pub button: PuglButtonEvent,
    #[doc = "< #PUGL_CONFIGURE"]
    pub configure: PuglConfigureEvent,
    #[doc = "< #PUGL_EXPOSE"]
    pub expose: PuglExposeEvent,
    #[doc = "< #PUGL_KEY_PRESS, #PUGL_KEY_RELEASE"]
    pub key: PuglKeyEvent,
    #[doc = "< #PUGL_TEXT"]
    pub text: PuglTextEvent,
    #[doc = "< #PUGL_POINTER_IN, #PUGL_POINTER_OUT"]
    pub crossing: PuglCrossingEvent,
    #[doc = "< #PUGL_MOTION"]
    pub motion: PuglMotionEvent,
    #[doc = "< #PUGL_SCROLL"]
    pub scroll: PuglScrollEvent,
    #[doc = "< #PUGL_FOCUS_IN, #PUGL_FOCUS_OUT"]
    pub focus: PuglFocusEvent,
    #[doc = "< #PUGL_CLIENT"]
    pub client: PuglClientEvent,
    #[doc = "< #PUGL_TIMER"]
    pub timer: PuglTimerEvent,
    #[doc = "< #PUGL_DATA_OFFER"]
    pub offer: PuglDataOfferEvent,
    #[doc = "< #PUGL_DATA"]
    pub data: PuglDataEvent,
}
#[doc = "< Success"]
pub const PUGL_SUCCESS: PuglStatus = 0;
#[doc = "< Non-fatal failure"]
pub const PUGL_FAILURE: PuglStatus = 1;
#[doc = "< Unknown system error"]
pub const PUGL_UNKNOWN_ERROR: PuglStatus = 2;
#[doc = "< Invalid or missing backend"]
pub const PUGL_BAD_BACKEND: PuglStatus = 3;
#[doc = "< Invalid view configuration"]
pub const PUGL_BAD_CONFIGURATION: PuglStatus = 4;
#[doc = "< Invalid parameter"]
pub const PUGL_BAD_PARAMETER: PuglStatus = 5;
#[doc = "< Backend initialization failed"]
pub const PUGL_BACKEND_FAILED: PuglStatus = 6;
#[doc = "< Class registration failed"]
pub const PUGL_REGISTRATION_FAILED: PuglStatus = 7;
#[doc = "< System view realization failed"]
pub const PUGL_REALIZE_FAILED: PuglStatus = 8;
#[doc = "< Failed to set pixel format"]
pub const PUGL_SET_FORMAT_FAILED: PuglStatus = 9;
#[doc = "< Failed to create drawing context"]
pub const PUGL_CREATE_CONTEXT_FAILED: PuglStatus = 10;
#[doc = "< Unsupported operation"]
pub const PUGL_UNSUPPORTED: PuglStatus = 11;
#[doc = "< Failed to allocate memory"]
pub const PUGL_NO_MEMORY: PuglStatus = 12;
#[doc = " Return status code"]
pub type PuglStatus = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Return a string describing a status code"]
    pub fn puglStrerror(status: PuglStatus) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglWorldImpl {
    _unused: [u8; 0],
}
#[doc = "The \"world\" of application state.\n\nThe world represents everything that is not associated with a particular\nview.  Several worlds can be created in a single process, but code using\ndifferent worlds must be isolated so they are never mixed.  Views are\nstrongly associated with the world they were created in."]
pub type PuglWorld = PuglWorldImpl;
#[doc = " Handle for the world's opaque user data"]
pub type PuglWorldHandle = *mut ::std::os::raw::c_void;
#[doc = "< Top-level application"]
pub const PUGL_PROGRAM: PuglWorldType = 0;
#[doc = "< Plugin or module within a larger application"]
pub const PUGL_MODULE: PuglWorldType = 1;
#[doc = " The type of a World"]
pub type PuglWorldType = ::std::os::raw::c_uint;
#[doc = "Set up support for threads if necessary.\n\nX11: Calls XInitThreads() which is required for some drivers."]
pub const PUGL_WORLD_THREADS: PuglWorldFlag = 1;
#[doc = " World flags"]
pub type PuglWorldFlag = ::std::os::raw::c_uint;
#[doc = " Bitwise OR of #PuglWorldFlag values"]
pub type PuglWorldFlags = u32;
unsafe extern "C" {
    #[doc = "Create a new world.\n\n@param type The type, which dictates what this world is responsible for.\n@param flags Flags to control world features.\n@return A new world, which must be later freed with puglFreeWorld()."]
    pub fn puglNewWorld(type_: PuglWorldType, flags: PuglWorldFlags) -> *mut PuglWorld;
}
unsafe extern "C" {
    #[doc = " Free a world allocated with puglNewWorld()"]
    pub fn puglFreeWorld(world: *mut PuglWorld);
}
unsafe extern "C" {
    #[doc = "Set the user data for the world.\n\nThis is usually a pointer to a struct that contains all the state which must\nbe accessed by several views.\n\nThe handle is opaque to Pugl and is not interpreted in any way."]
    pub fn puglSetWorldHandle(world: *mut PuglWorld, handle: PuglWorldHandle);
}
unsafe extern "C" {
    #[doc = " Get the user data for the world"]
    pub fn puglGetWorldHandle(world: *mut PuglWorld) -> PuglWorldHandle;
}
unsafe extern "C" {
    #[doc = "Return a pointer to the native handle of the world.\n\nX11: Returns a pointer to the `Display`.\n\nMacOS: Returns a pointer to the `NSApplication`.\n\nWindows: Returns the `HMODULE` of the calling process."]
    pub fn puglGetNativeWorld(world: *mut PuglWorld) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "Set a string property to configure the world or application.\n\nThe string value only needs to be valid for the duration of this call, it\nwill be copied if necessary."]
    pub fn puglSetWorldString(
        world: *mut PuglWorld,
        key: PuglStringHint,
        value: *const ::std::os::raw::c_char,
    ) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Get a world or application string property.\n\nThe returned string should be accessed immediately, or copied.  It may\nbecome invalid upon any call to any function that manipulates the same view."]
    pub fn puglGetWorldString(
        world: *const PuglWorld,
        key: PuglStringHint,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Return the time in seconds.\n\nThis is a monotonically increasing clock with high resolution.  The returned\ntime is only useful to compare against other times returned by this\nfunction, its absolute value has no meaning."]
    pub fn puglGetTime(world: *const PuglWorld) -> f64;
}
unsafe extern "C" {
    #[doc = "Update by processing events from the window system.\n\nThis function is a single iteration of the main loop, and should be called\nrepeatedly to update all views.\n\nIf `timeout` is zero, then this function will not block.  Plugins should\nalways use a timeout of zero to avoid blocking the host.\n\nIf a positive `timeout` is given, then events will be processed for that\namount of time, starting from when this function was called.\n\nIf a negative `timeout` is given, this function will block indefinitely\nuntil an event occurs.\n\nFor continuously animating programs, a timeout that is a reasonable fraction\nof the ideal frame period should be used, to minimize input latency by\nensuring that as many input events are consumed as possible before drawing.\n\n@return #PUGL_SUCCESS if events are read, #PUGL_FAILURE if no events are\nread, or an error."]
    pub fn puglUpdate(world: *mut PuglWorld, timeout: f64) -> PuglStatus;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglViewImpl {
    _unused: [u8; 0],
}
#[doc = " A drawable region that receives events"]
pub type PuglView = PuglViewImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PuglBackendImpl {
    _unused: [u8; 0],
}
#[doc = "A graphics backend.\n\nThe backend dictates how graphics are set up for a view, and how drawing is\nperformed.  A backend must be set by calling puglSetBackend() before\nrealising a view.\n\nIf you are using a local copy of Pugl, it is possible to implement a custom\nbackend.  See the definition of `PuglBackendImpl` in the source code for\ndetails."]
pub type PuglBackend = PuglBackendImpl;
#[doc = "A native view handle.\n\nX11: This is a `Window`.\n\nMacOS: This is a pointer to an `NSView*`.\n\nWindows: This is a `HWND`."]
pub type PuglNativeView = usize;
#[doc = " Handle for a view's opaque user data"]
pub type PuglHandle = *mut ::std::os::raw::c_void;
#[doc = "< OpenGL render API (GL/GLES)"]
pub const PUGL_CONTEXT_API: PuglViewHint = 0;
#[doc = "< OpenGL context major version"]
pub const PUGL_CONTEXT_VERSION_MAJOR: PuglViewHint = 1;
#[doc = "< OpenGL context minor version"]
pub const PUGL_CONTEXT_VERSION_MINOR: PuglViewHint = 2;
#[doc = "< OpenGL context profile (core/compatibility)"]
pub const PUGL_CONTEXT_PROFILE: PuglViewHint = 3;
#[doc = "< OpenGL context debugging enabled"]
pub const PUGL_CONTEXT_DEBUG: PuglViewHint = 4;
#[doc = "< Number of bits for red channel"]
pub const PUGL_RED_BITS: PuglViewHint = 5;
#[doc = "< Number of bits for green channel"]
pub const PUGL_GREEN_BITS: PuglViewHint = 6;
#[doc = "< Number of bits for blue channel"]
pub const PUGL_BLUE_BITS: PuglViewHint = 7;
#[doc = "< Number of bits for alpha channel"]
pub const PUGL_ALPHA_BITS: PuglViewHint = 8;
#[doc = "< Number of bits for depth buffer"]
pub const PUGL_DEPTH_BITS: PuglViewHint = 9;
#[doc = "< Number of bits for stencil buffer"]
pub const PUGL_STENCIL_BITS: PuglViewHint = 10;
#[doc = "< Number of sample buffers (AA)"]
pub const PUGL_SAMPLE_BUFFERS: PuglViewHint = 11;
#[doc = "< Number of samples per pixel (AA)"]
pub const PUGL_SAMPLES: PuglViewHint = 12;
#[doc = "< True if double buffering should be used"]
pub const PUGL_DOUBLE_BUFFER: PuglViewHint = 13;
#[doc = "< Number of frames between buffer swaps"]
pub const PUGL_SWAP_INTERVAL: PuglViewHint = 14;
#[doc = "< True if view should be resizable"]
pub const PUGL_RESIZABLE: PuglViewHint = 15;
#[doc = "< True if key repeat events are ignored"]
pub const PUGL_IGNORE_KEY_REPEAT: PuglViewHint = 16;
#[doc = "< Refresh rate in Hz"]
pub const PUGL_REFRESH_RATE: PuglViewHint = 17;
#[doc = "< View type (a #PuglViewType)"]
pub const PUGL_VIEW_TYPE: PuglViewHint = 18;
#[doc = "< True if window frame should be dark"]
pub const PUGL_DARK_FRAME: PuglViewHint = 19;
#[doc = " An integer hint for configuring a view"]
pub type PuglViewHint = ::std::os::raw::c_uint;
#[doc = "< Generic trinary: unset"]
pub const PUGL_DONT_CARE: PuglViewHintValue = -1;
#[doc = "< Generic trinary: false"]
pub const PUGL_FALSE: PuglViewHintValue = 0;
#[doc = "< Generic trinary: true"]
pub const PUGL_TRUE: PuglViewHintValue = 1;
#[doc = "< For #PUGL_CONTEXT_API"]
pub const PUGL_OPENGL_API: PuglViewHintValue = 2;
#[doc = "< For #PUGL_CONTEXT_API"]
pub const PUGL_OPENGL_ES_API: PuglViewHintValue = 3;
#[doc = "< For #PUGL_CONTEXT_PROFILE"]
pub const PUGL_OPENGL_CORE_PROFILE: PuglViewHintValue = 4;
#[doc = "< For #PUGL_CONTEXT_PROFILE"]
pub const PUGL_OPENGL_COMPATIBILITY_PROFILE: PuglViewHintValue = 5;
#[doc = " A special view hint value"]
pub type PuglViewHintValue = ::std::os::raw::c_int;
#[doc = "< A normal top-level window"]
pub const PUGL_VIEW_TYPE_NORMAL: PuglViewType = 0;
#[doc = "< A utility window like a palette or toolbox"]
pub const PUGL_VIEW_TYPE_UTILITY: PuglViewType = 1;
#[doc = "< A dialog window"]
pub const PUGL_VIEW_TYPE_DIALOG: PuglViewType = 2;
#[doc = " View type"]
pub type PuglViewType = ::std::os::raw::c_uint;
#[doc = "Default position.\n\nThis is used as the position during window creation as a default, if no\nother position is specified.  It isn't necessary to set a default position\n(unlike the default size, which is required).  If not even a default\nposition is set, then the window will be created at an arbitrary position.\nThis position is a best-effort attempt to do the most reasonable thing for\nthe initial display of the window, for example, by centering.  Note that\nit is implementation-defined, subject to change, platform-specific, and\nfor embedded views, may no longer make sense if the parent's size is\nadjusted.  Code that wants to make assumptions about the initial position\nmust set the default to a specific valid one, such as `{0, 0}`."]
pub const PUGL_DEFAULT_POSITION: PuglPositionHint = 0;
#[doc = "Current position.\n\nThis reflects the current position of the view, which may be different from\nthe default position if the view has been moved by the user, window\nmanager, or for any other reason.  Typically, it overrides the\ndefault position."]
pub const PUGL_CURRENT_POSITION: PuglPositionHint = 1;
#[doc = "A hint for configuring/constraining the position of a view.\n\nThe system will attempt to make the view's window adhere to these, but they\nare suggestions, not hard constraints.  Applications should handle any view\nposition gracefully.\n\nAn unset position has `INT16_MIN` (-32768) for both `x` and `y`.  In\npractice, set positions should be between -16000 and 16000 for portability.\nUsually, the origin is the top left of the display, although negative\ncoordinates are possible, particularly on multi-display system."]
pub type PuglPositionHint = ::std::os::raw::c_uint;
#[doc = "Default size.\n\nThis is used as the size during window creation as a default, if no other\nsize is specified."]
pub const PUGL_DEFAULT_SIZE: PuglSizeHint = 0;
#[doc = "Current size.\n\nThis reflects the current size of the view, which may be different from\nthe default size if the view is resizable.  Typically, it overrides the\ndefault size."]
pub const PUGL_CURRENT_SIZE: PuglSizeHint = 1;
#[doc = "Minimum size.\n\nIf set, the view's size should be constrained to be at least this large."]
pub const PUGL_MIN_SIZE: PuglSizeHint = 2;
#[doc = "Maximum size.\n\nIf set, the view's size should be constrained to be at most this large."]
pub const PUGL_MAX_SIZE: PuglSizeHint = 3;
#[doc = "Fixed aspect ratio.\n\nIf set, the view's size should be constrained to this aspect ratio.\nMutually exclusive with #PUGL_MIN_ASPECT and #PUGL_MAX_ASPECT."]
pub const PUGL_FIXED_ASPECT: PuglSizeHint = 4;
#[doc = "Minimum aspect ratio.\n\nIf set, the view's size should be constrained to an aspect ratio no lower\nthan this.  Mutually exclusive with #PUGL_FIXED_ASPECT."]
pub const PUGL_MIN_ASPECT: PuglSizeHint = 5;
#[doc = "Maximum aspect ratio.\n\nIf set, the view's size should be constrained to an aspect ratio no higher\nthan this.  Mutually exclusive with #PUGL_FIXED_ASPECT."]
pub const PUGL_MAX_ASPECT: PuglSizeHint = 6;
#[doc = "A hint for configuring/constraining the size of a view.\n\nThe system will attempt to make the view's window adhere to these, but they\nare suggestions, not hard constraints.  Applications should handle any view\nsize gracefully."]
pub type PuglSizeHint = ::std::os::raw::c_uint;
#[doc = " A function called when an event occurs"]
pub type PuglEventFunc = ::std::option::Option<
    unsafe extern "C" fn(view: *mut PuglView, event: *const PuglEvent) -> PuglStatus,
>;
unsafe extern "C" {
    #[doc = "Create a new view.\n\nA newly created view does not correspond to a real system view or window.\nIt must first be configured, then the system view can be created with\npuglRealize()."]
    pub fn puglNewView(world: *mut PuglWorld) -> *mut PuglView;
}
unsafe extern "C" {
    #[doc = " Free a view created with puglNewView()"]
    pub fn puglFreeView(view: *mut PuglView);
}
unsafe extern "C" {
    #[doc = " Return the world that `view` is a part of"]
    pub fn puglGetWorld(view: *mut PuglView) -> *mut PuglWorld;
}
unsafe extern "C" {
    #[doc = "Set the user data for a view.\n\nThis is usually a pointer to a struct that contains all the state which must\nbe accessed by a view.  Everything needed to process events should be stored\nhere, not in static variables.\n\nThe handle is opaque to Pugl and is not interpreted in any way."]
    pub fn puglSetHandle(view: *mut PuglView, handle: PuglHandle);
}
unsafe extern "C" {
    #[doc = " Get the user data for a view"]
    pub fn puglGetHandle(view: *mut PuglView) -> PuglHandle;
}
unsafe extern "C" {
    #[doc = "Set the graphics backend to use for a view.\n\nThis must be called once to set the graphics backend before calling\npuglRealize().\n\nPugl includes the following backends:\n\n- puglCairoBackend()\n- puglGlBackend()\n- puglVulkanBackend()\n\nNote that backends are modular and not compiled into the main Pugl library\nto avoid unnecessary dependencies.  To use a particular backend,\napplications must link against the appropriate backend library, or be sure\nto compile in the appropriate code if using a local copy of Pugl."]
    pub fn puglSetBackend(view: *mut PuglView, backend: *const PuglBackend) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = " Return the graphics backend used by a view"]
    pub fn puglGetBackend(view: *const PuglView) -> *const PuglBackend;
}
unsafe extern "C" {
    #[doc = " Set the function to call when an event occurs"]
    pub fn puglSetEventFunc(view: *mut PuglView, eventFunc: PuglEventFunc) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Set a hint to configure view properties.\n\nThis only has an effect when called before puglRealize()."]
    pub fn puglSetViewHint(
        view: *mut PuglView,
        hint: PuglViewHint,
        value: ::std::os::raw::c_int,
    ) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Get the value for a view hint.\n\nIf the view has been realized, this can be used to get the actual value of a\nhint which was initially set to PUGL_DONT_CARE, or has been adjusted from\nthe suggested value."]
    pub fn puglGetViewHint(view: *const PuglView, hint: PuglViewHint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set a string property to configure view properties.\n\nThis is similar to puglSetViewHint() but sets hints with string values.  The\nstring value only needs to be valid for the duration of this call, it will\nbe copied if necessary."]
    pub fn puglSetViewString(
        view: *mut PuglView,
        key: PuglStringHint,
        value: *const ::std::os::raw::c_char,
    ) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Get a view string property.\n\nThe returned string should be accessed immediately, or copied.  It may\nbecome invalid upon any call to any function that manipulates the same view."]
    pub fn puglGetViewString(
        view: *const PuglView,
        key: PuglStringHint,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Return the scale factor of the view.\n\nThis factor describe how large UI elements (especially text) should be\ncompared to \"normal\".  For example, 2.0 means the UI should be drawn twice\nas large.\n\n\"Normal\" is loosely defined, but means a good size on a \"standard DPI\"\ndisplay (around 96 DPI).  In other words, the scale 1.0 should have text\nthat is reasonably sized on a 96 DPI display, and the scale 2.0 should have\ntext twice that large."]
    pub fn puglGetScaleFactor(view: *const PuglView) -> f64;
}
unsafe extern "C" {
    #[doc = "Get a position hint for the view.\n\nThis can be used to get the default or current position of a view, in screen\ncoordinates with an upper left origin."]
    pub fn puglGetPositionHint(view: *const PuglView, hint: PuglPositionHint) -> PuglPoint;
}
unsafe extern "C" {
    #[doc = "Set a position hint for the view.\n\nThis can be used to set the default or current position of a view.\n\nThis should be called before puglRealize() so the initial window for the\nview can be configured correctly.  It may also be used dynamically after the\nwindow is realized, for some hints.\n\n@return An error code on failure, but always succeeds if the view is not yet\nrealized."]
    pub fn puglSetPositionHint(
        view: *mut PuglView,
        hint: PuglPositionHint,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Get a size hint for the view.\n\nThis can be used to get the default, current, minimum, and maximum size of a\nview, as well as the supported range of aspect ratios."]
    pub fn puglGetSizeHint(view: *const PuglView, hint: PuglSizeHint) -> PuglArea;
}
unsafe extern "C" {
    #[doc = "Set a size hint for the view.\n\nThis can be used to set the default, current, minimum, and maximum size of a\nview, as well as the supported range of aspect ratios.\n\nThis should be called before puglRealize() so the initial window for the\nview can be configured correctly.  It may also be used dynamically after the\nwindow is realized, for some hints.\n\n@return An error code on failure, but always succeeds if the view is not yet\nrealized."]
    pub fn puglSetSizeHint(
        view: *mut PuglView,
        hint: PuglSizeHint,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Set the parent for embedding a view in an existing window.\n\nThis must be called before puglRealize(), reparenting is not supported."]
    pub fn puglSetParent(view: *mut PuglView, parent: PuglNativeView) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = " Return the parent window this view is embedded in, or null"]
    pub fn puglGetParent(view: *const PuglView) -> PuglNativeView;
}
unsafe extern "C" {
    #[doc = "Set the transient parent of the window.\n\nSet this for transient children like dialogs, to have them properly\nassociated with their parent window.  This should be called before\npuglRealize().\n\nA view can either have a parent (for embedding) or a transient parent (for\ntop-level windows like dialogs), but not both."]
    pub fn puglSetTransientParent(view: *mut PuglView, parent: PuglNativeView) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Return the transient parent of the window.\n\n@return The native handle to the window this view is a transient child of,\nor null."]
    pub fn puglGetTransientParent(view: *const PuglView) -> PuglNativeView;
}
unsafe extern "C" {
    #[doc = "Realize a view by creating a corresponding system view or window.\n\nAfter this call, the (initially invisible) underlying system view exists and\ncan be accessed with puglGetNativeView().\n\nThe view should be fully configured using the above functions before this is\ncalled.  This function may only be called once per view."]
    pub fn puglRealize(view: *mut PuglView) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Unrealize a view by destroying the corresponding system view or window.\n\nThis is the inverse of puglRealize().  After this call, the view no longer\ncorresponds to a real system view, and can be realized again later."]
    pub fn puglUnrealize(view: *mut PuglView) -> PuglStatus;
}
#[doc = "Realize and show the window without intentionally raising it.\n\nThis will weakly \"show\" the window but without making any effort to raise\nit.  Depending on the platform or system configuration, the window may be\nraised above some others regardless."]
pub const PUGL_SHOW_PASSIVE: PuglShowCommand = 0;
#[doc = "Raise the window to the top of the application's stack.\n\nThis is the normal \"well-behaved\" way to show and raise the window, which\nshould be used in most cases."]
pub const PUGL_SHOW_RAISE: PuglShowCommand = 1;
#[doc = "Aggressively force the window to be raised to the top.\n\nThis will attempt to raise the window to the top, even if this isn't the\nactive application, or if doing so would otherwise go against the\nplatform's guidelines.  This generally shouldn't be used, and isn't\nguaranteed to work.  On modern Windows systems, the active application\nmust explicitly grant permission for others to steal the foreground from\nit."]
pub const PUGL_SHOW_FORCE_RAISE: PuglShowCommand = 2;
#[doc = " A command to control the behaviour of puglShow()"]
pub type PuglShowCommand = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = "Show the view.\n\nIf the view has not yet been realized, the first call to this function will\ndo so automatically.\n\nIf the view is currently hidden, it will be shown and possibly raised to the\ntop depending on the platform."]
    pub fn puglShow(view: *mut PuglView, command: PuglShowCommand) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = " Hide the current window"]
    pub fn puglHide(view: *mut PuglView) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Set a view state, if supported by the system.\n\nThis can be used to manipulate the window into various special states, but\nnote that not all states are supported on all systems.  This function may\nreturn failure or an error if the platform implementation doesn't\n\"understand\" how to set the given style, but the return value here can't be\nused to determine if the state has actually been set.  Any changes to the\nactual state of the view will arrive in later configure events."]
    pub fn puglSetViewStyle(view: *mut PuglView, flags: PuglViewStyleFlags) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Return true if the view currently has a state flag set.\n\nThe result is determined based on the state announced in the last configure\nevent."]
    pub fn puglGetViewStyle(view: *const PuglView) -> PuglViewStyleFlags;
}
unsafe extern "C" {
    #[doc = " Return true iff the view is currently visible"]
    pub fn puglGetVisible(view: *const PuglView) -> bool;
}
unsafe extern "C" {
    #[doc = " Return the native window handle"]
    pub fn puglGetNativeView(view: *mut PuglView) -> PuglNativeView;
}
unsafe extern "C" {
    #[doc = "Get the graphics context.\n\nThis is a backend-specific context used for drawing if the backend graphics\nAPI requires one.  It is only available during an expose.\n\nCairo: Returns a pointer to a\n[cairo_t](http://www.cairographics.org/manual/cairo-cairo-t.html).\n\nAll other backends: returns null."]
    pub fn puglGetContext(view: *mut PuglView) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "Request a redisplay for the entire view.\n\nThis will cause an expose event to be dispatched later.  If called from\nwithin the event handler, the expose should arrive at the end of the current\nevent loop iteration, though this is not strictly guaranteed on all\nplatforms.  If called elsewhere, an expose will be enqueued to be processed\nin the next event loop iteration."]
    pub fn puglObscureView(view: *mut PuglView) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "\"Obscure\" a region so it will be exposed in the next render.\n\nThis will cause an expose event to be dispatched later.  If called from\nwithin the event handler, the expose should arrive at the end of the current\nevent loop iteration, though this is not strictly guaranteed on all\nplatforms.  If called elsewhere, an expose will be enqueued to be processed\nin the next event loop iteration.\n\nThe region is clamped to the size of the view if necessary.\n\n@param view The view to expose later.\n@param x The top-left X coordinate of the rectangle to obscure.\n@param y The top-left Y coordinate of the rectangle to obscure.\n@param width The width of the rectangle to obscure.\n@param height The height coordinate of the rectangle to obscure."]
    pub fn puglObscureRegion(
        view: *mut PuglView,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> PuglStatus;
}
#[doc = "< Default pointing arrow"]
pub const PUGL_CURSOR_ARROW: PuglCursor = 0;
#[doc = "< Caret (I-Beam) for text entry"]
pub const PUGL_CURSOR_CARET: PuglCursor = 1;
#[doc = "< Cross-hair"]
pub const PUGL_CURSOR_CROSSHAIR: PuglCursor = 2;
#[doc = "< Hand with a pointing finger"]
pub const PUGL_CURSOR_HAND: PuglCursor = 3;
#[doc = "< Operation not allowed"]
pub const PUGL_CURSOR_NO: PuglCursor = 4;
#[doc = "< Left/right arrow for horizontal resize"]
pub const PUGL_CURSOR_LEFT_RIGHT: PuglCursor = 5;
#[doc = "< Up/down arrow for vertical resize"]
pub const PUGL_CURSOR_UP_DOWN: PuglCursor = 6;
#[doc = "< Diagonal arrow for down/right resize"]
pub const PUGL_CURSOR_UP_LEFT_DOWN_RIGHT: PuglCursor = 7;
#[doc = "< Diagonal arrow for down/left resize"]
pub const PUGL_CURSOR_UP_RIGHT_DOWN_LEFT: PuglCursor = 8;
#[doc = "< Omnidirectional \"arrow\" for scrolling"]
pub const PUGL_CURSOR_ALL_SCROLL: PuglCursor = 9;
#[doc = "A mouse cursor type.\n\nThis is a portable subset of mouse cursors that exist on X11, MacOS, and\nWindows."]
pub type PuglCursor = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = "Grab the keyboard input focus.\n\nNote that this will fail if the view is not mapped and so should not, for\nexample, be called immediately after puglShow().\n\n@return #PUGL_SUCCESS if the focus was successfully grabbed, or an error."]
    pub fn puglGrabFocus(view: *mut PuglView) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = " Return whether `view` has the keyboard input focus"]
    pub fn puglHasFocus(view: *const PuglView) -> bool;
}
unsafe extern "C" {
    #[doc = "Request data from the general copy/paste clipboard.\n\nA #PUGL_DATA_OFFER event will be sent if data is available."]
    pub fn puglPaste(view: *mut PuglView) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Return the number of types available for the data in a clipboard.\n\nReturns zero if the clipboard is empty."]
    pub fn puglGetNumClipboardTypes(view: *const PuglView) -> u32;
}
unsafe extern "C" {
    #[doc = "Return the identifier of a type available in a clipboard.\n\nThis is usually a MIME type, but may also be another platform-specific type\nidentifier.  Applications must ignore any type they do not recognize.\n\nReturns null if `typeIndex` is out of bounds according to\npuglGetNumClipboardTypes()."]
    pub fn puglGetClipboardType(
        view: *const PuglView,
        typeIndex: u32,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Accept data offered from a clipboard.\n\nTo accept data, this must be called while handling a #PUGL_DATA_OFFER event.\nDoing so will request the data from the source as the specified type.  When\nthe data is available, a #PUGL_DATA event will be sent to the view which can\nthen retrieve the data with puglGetClipboard().\n\n@param view The view.\n\n@param offer The data offer event.\n\n@param typeIndex The index of the type that the view will accept.  This is\nthe `typeIndex` argument to the call of puglGetClipboardType() that returned\nthe accepted type."]
    pub fn puglAcceptOffer(
        view: *mut PuglView,
        offer: *const PuglDataOfferEvent,
        typeIndex: u32,
    ) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Set the clipboard contents.\n\nThis sets the system clipboard contents, which can be retrieved with\npuglGetClipboard() or pasted into other applications.\n\n@param view The view.\n@param type The MIME type of the data, \"text/plain\" is assumed if `NULL`.\n@param data The data to copy to the clipboard.\n@param len The length of data in bytes (including terminator if necessary)."]
    pub fn puglSetClipboard(
        view: *mut PuglView,
        type_: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Get the clipboard contents.\n\nThis gets the system clipboard contents, which may have been set with\npuglSetClipboard() or copied from another application.\n\n@param view The view.\n@param typeIndex Index of the data type to get the item as.\n@param[out] len Set to the length of the data in bytes.\n@return The clipboard contents, or null."]
    pub fn puglGetClipboard(
        view: *mut PuglView,
        typeIndex: u32,
        len: *mut usize,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "Set the mouse cursor.\n\nThis changes the system cursor that is displayed when the pointer is inside\nthe view.  May fail if setting the cursor is not supported on this system,\nfor example if compiled on X11 without Xcursor support.\n\n@return #PUGL_BAD_PARAMETER if the given cursor is invalid,\n#PUGL_UNSUPPORTED if setting the cursor is not supported on this system, or\nanother error if the cursor is known but loading it fails."]
    pub fn puglSetCursor(view: *mut PuglView, cursor: PuglCursor) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Activate a repeating timer event.\n\nThis starts a timer which will send a #PuglTimerEvent to `view` every\n`timeout` seconds.  This can be used to perform some action in a view at a\nregular interval with relatively low frequency.  Note that the frequency of\ntimer events may be limited by how often puglUpdate() is called.\n\nIf the given timer already exists, it is replaced.\n\n@param view The view to begin sending #PUGL_TIMER events to.\n\n@param id The identifier for this timer.  This is an application-specific ID\nthat should be a low number, typically the value of a constant or `enum`\nthat starts from 0.  There is a platform-specific limit to the number of\nsupported timers, and overhead associated with each, so applications should\ncreate only a few timers and perform several tasks in one if necessary.\n\n@param timeout The period, in seconds, of this timer.  This is not\nguaranteed to have a resolution better than 10ms (the maximum timer\nresolution on Windows) and may be rounded up if it is too short.  On X11 and\nMacOS, a resolution of about 1ms can usually be relied on.\n\n@return #PUGL_FAILURE if timers are not supported by the system,\n#PUGL_UNKNOWN_ERROR if setting the timer failed."]
    pub fn puglStartTimer(view: *mut PuglView, id: usize, timeout: f64) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Stop an active timer.\n\n@param view The view that the timer is set for.\n@param id The ID previously passed to puglStartTimer().\n\n@return #PUGL_FAILURE if timers are not supported by this system,\n#PUGL_UNKNOWN_ERROR if stopping the timer failed."]
    pub fn puglStopTimer(view: *mut PuglView, id: usize) -> PuglStatus;
}
unsafe extern "C" {
    #[doc = "Send an event to a view via the window system.\n\nIf supported, the event will be delivered to the view via the event loop\nlike other events.  Note that this function only works for certain event\ntypes.\n\nCurrently, only #PUGL_CLIENT events are supported on all platforms.\n\nX11: A #PUGL_EXPOSE event can be sent, which is similar to calling\npuglObscureRegion(), but will always send a message to the X server, even\nwhen called in an event handler.\n\n@return #PUGL_UNSUPPORTED if sending events of this type is not supported,\n#PUGL_UNKNOWN_ERROR if sending the event failed."]
    pub fn puglSendEvent(view: *mut PuglView, event: *const PuglEvent) -> PuglStatus;
}
